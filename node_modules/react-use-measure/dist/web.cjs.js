'use strict';

var react = require('react');
var debounce = require('debounce');
var resizeObserver = require('@juggle/resize-observer');

var ResizeObserver = window && window.ResizeObserver || resizeObserver.ResizeObserver;

function useMeasure(_temp) {
  var _ref = _temp === void 0 ? {
    debounce: 0,
    scroll: false
  } : _temp,
      debounce$1 = _ref.debounce,
      scroll = _ref.scroll;

  var _useState = react.useState({
    left: 0,
    top: 0,
    width: 0,
    height: 0,
    bottom: 0,
    right: 0,
    x: 0,
    y: 0
  }),
      bounds = _useState[0],
      set = _useState[1];

  var lastBounds = react.useRef(bounds);

  var _useElementState = useElementState({
    element: null,
    scrollContainers: null
  }, function (element) {
    return {
      element: element,
      scrollContainers: findScrollContainers(element)
    };
  }),
      ref = _useElementState[0],
      state = _useElementState[1];

  var _useMemo = react.useMemo(function () {
    var callback = function callback() {
      if (!state.current.element) return;

      var _ref2 = state.current.element.getBoundingClientRect(),
          left = _ref2.left,
          top = _ref2.top,
          width = _ref2.width,
          height = _ref2.height,
          bottom = _ref2.bottom,
          right = _ref2.right,
          x = _ref2.x,
          y = _ref2.y;

      var size = {
        left: left,
        top: top,
        width: width,
        height: height,
        bottom: bottom,
        right: right,
        x: x,
        y: y
      };
      Object.freeze(size);
      if (!areBoundsEqual(lastBounds.current, size)) set(lastBounds.current = size);
    };

    return [debounce$1 ? debounce.debounce(callback, typeof debounce$1 === 'number' ? debounce$1 : debounce$1.resize) : callback, debounce$1 ? debounce.debounce(callback, typeof debounce$1 === 'number' ? debounce$1 : debounce$1.scroll) : callback];
  }, [set, debounce$1]),
      resizeChange = _useMemo[0],
      scrollChange = _useMemo[1];

  useOnScroll(scroll ? state.current.scrollContainers : null, scrollChange);
  useOnWindowResize(resizeChange);
  react.useEffect(function () {
    var ro = new ResizeObserver(resizeChange);
    if (state.current.element) ro.observe(state.current.element);
    return function () {
      return ro.disconnect();
    };
  }, [state.current.element, resizeChange]);
  return [ref, bounds];
} // Lets you reference an element and stores state based off that same element


function useElementState(initialState, elementToState) {
  var state = react.useRef(initialState);
  var lastElement = react.useRef(null);
  var ref = react.useCallback( // did the reference change?
  function (node) {
    return node && node !== lastElement.current && (state.current = elementToState(lastElement.current = node));
  }, [elementToState]);
  return [ref, state];
} // Adds native scroll listeners to a list of elements


function useOnScroll(scrollContainers, onScroll) {
  react.useEffect(function () {
    if (!scrollContainers) return;
    var cb = onScroll;
    var elements = [window].concat(scrollContainers);
    elements.forEach(function (element) {
      return element.addEventListener('scroll', cb, {
        capture: true,
        passive: true
      });
    });
    return function () {
      return elements.forEach(function (element) {
        return element.removeEventListener('scroll', cb, true);
      });
    };
  }, [onScroll, scrollContainers]);
} // Adds native resize listener to window


function useOnWindowResize(onWindowResize) {
  react.useEffect(function () {
    var cb = onWindowResize;
    window.addEventListener('resize', cb);
    return function () {
      return window.removeEventListener('resize', cb);
    };
  }, [onWindowResize]);
} // Returns a list of scroll offsets


function findScrollContainers(element) {
  var result = [];
  if (!element || element === document.body) return result;

  var _window$getComputedSt = window.getComputedStyle(element),
      overflow = _window$getComputedSt.overflow,
      overflowX = _window$getComputedSt.overflowX,
      overflowY = _window$getComputedSt.overflowY;

  if ([overflow, overflowX, overflowY].some(function (prop) {
    return prop === 'auto' || prop === 'scroll';
  })) result.push(element);
  return [].concat(result, findScrollContainers(element.parentElement));
} // Checks if element boundaries are equal


var keys = ['x', 'y', 'top', 'bottom', 'left', 'right', 'width', 'height'];

var areBoundsEqual = function areBoundsEqual(a, b) {
  return keys.every(function (key) {
    return a[key] === b[key];
  });
};

module.exports = useMeasure;
