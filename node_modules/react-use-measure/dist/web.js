import { useState, useRef, useMemo, useEffect, useCallback } from 'react';
import { debounce } from 'debounce';
import { ResizeObserver as ResizeObserver$1 } from '@juggle/resize-observer';

const ResizeObserver = window && window.ResizeObserver || ResizeObserver$1;

function useMeasure({
  debounce: debounce$1,
  scroll
} = {
  debounce: 0,
  scroll: false
}) {
  const [bounds, set] = useState({
    left: 0,
    top: 0,
    width: 0,
    height: 0,
    bottom: 0,
    right: 0,
    x: 0,
    y: 0
  });
  const lastBounds = useRef(bounds);
  let [ref, state] = useElementState({
    element: null,
    scrollContainers: null
  }, element => ({
    element,
    scrollContainers: findScrollContainers(element)
  }));
  const [resizeChange, scrollChange] = useMemo(() => {
    const callback = () => {
      if (!state.current.element) return;
      const {
        left,
        top,
        width,
        height,
        bottom,
        right,
        x,
        y
      } = state.current.element.getBoundingClientRect();
      const size = {
        left,
        top,
        width,
        height,
        bottom,
        right,
        x,
        y
      };
      Object.freeze(size);
      if (!areBoundsEqual(lastBounds.current, size)) set(lastBounds.current = size);
    };

    return [debounce$1 ? debounce(callback, typeof debounce$1 === 'number' ? debounce$1 : debounce$1.resize) : callback, debounce$1 ? debounce(callback, typeof debounce$1 === 'number' ? debounce$1 : debounce$1.scroll) : callback];
  }, [set, debounce$1]);
  useOnScroll(scroll ? state.current.scrollContainers : null, scrollChange);
  useOnWindowResize(resizeChange);
  useEffect(() => {
    const ro = new ResizeObserver(resizeChange);
    if (state.current.element) ro.observe(state.current.element);
    return () => ro.disconnect();
  }, [state.current.element, resizeChange]);
  return [ref, bounds];
} // Lets you reference an element and stores state based off that same element


function useElementState(initialState, elementToState) {
  const state = useRef(initialState);
  const lastElement = useRef(null);
  const ref = useCallback( // did the reference change?
  node => node && node !== lastElement.current && (state.current = elementToState(lastElement.current = node)), [elementToState]);
  return [ref, state];
} // Adds native scroll listeners to a list of elements


function useOnScroll(scrollContainers, onScroll) {
  useEffect(() => {
    if (!scrollContainers) return;
    const cb = onScroll;
    const elements = [window, ...scrollContainers];
    elements.forEach(element => element.addEventListener('scroll', cb, {
      capture: true,
      passive: true
    }));
    return () => elements.forEach(element => element.removeEventListener('scroll', cb, true));
  }, [onScroll, scrollContainers]);
} // Adds native resize listener to window


function useOnWindowResize(onWindowResize) {
  useEffect(() => {
    const cb = onWindowResize;
    window.addEventListener('resize', cb);
    return () => window.removeEventListener('resize', cb);
  }, [onWindowResize]);
} // Returns a list of scroll offsets


function findScrollContainers(element) {
  const result = [];
  if (!element || element === document.body) return result;
  const {
    overflow,
    overflowX,
    overflowY
  } = window.getComputedStyle(element);
  if ([overflow, overflowX, overflowY].some(prop => prop === 'auto' || prop === 'scroll')) result.push(element);
  return [...result, ...findScrollContainers(element.parentElement)];
} // Checks if element boundaries are equal


const keys = ['x', 'y', 'top', 'bottom', 'left', 'right', 'width', 'height'];

const areBoundsEqual = (a, b) => keys.every(key => a[key] === b[key]);

export default useMeasure;
